<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Geräte</title>
  <!-- TailwindCSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Thin scrollbar styling for scrollable columns */
    .thin-scrollbar::-webkit-scrollbar {
      width: 6px;
    }
    .thin-scrollbar::-webkit-scrollbar-thumb {
      background-color: rgba(0, 0, 0, 0.1);
      border-radius: 3px;
    }
  </style>
</head>
<body class="bg-[#f5faff] min-h-screen font-sans">
  <div id="root"></div>
  <script type="module">
    // Import required libraries via ESM CDN. We avoid Zustand because it triggers errors under file://.
    import React, { useState, useEffect, useRef, useContext, createContext } from 'https://esm.sh/react@18.2.0';
    import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client?deps=react@18.2.0';
    import {
      HashRouter,
      Routes,
      Route,
      Link,
      useLocation
    } from 'https://esm.sh/react-router-dom@6.16.0?deps=react@18.2.0';
import {
      DndContext,
      closestCenter,
      rectIntersection,
      PointerSensor,
      KeyboardSensor,
      useSensor,
      useSensors,
      useDroppable
    } from 'https://esm.sh/@dnd-kit/core@6.3.1?deps=react@18.2.0';
    import {
      SortableContext,
      useSortable,
      verticalListSortingStrategy,
      sortableKeyboardCoordinates
    } from 'https://esm.sh/@dnd-kit/sortable@10.0.0?deps=react@18.2.0';
    import * as XLSX from 'https://esm.sh/xlsx@0.18.5';
    import dayjs from 'https://esm.sh/dayjs@1.11.10';
    import { v4 as uuidv4 } from 'https://esm.sh/uuid@9.0.0';

    // Global selected directory handle. When the user chooses a data folder,
    // this variable will hold a FileSystemDirectoryHandle. All subsequent
    // reads and writes for persistence will use this directory instead of
    // triggering file downloads via the browser. It is not persisted across
    // sessions because directory handles cannot be serialized to localStorage.
    window.selectedDirectoryHandle = null;

    // Helper alias for React.createElement to reduce verbosity
    const h = React.createElement;

    // Global error handlers to show errors on page for debugging.
    window.addEventListener('error', (event) => {
      document.body.innerHTML = '<pre style="padding:1rem;color:red">JS Error: ' + event.message + '\n' + event.filename + ':' + event.lineno + '</pre>';
    });
    window.addEventListener('unhandledrejection', (event) => {
      document.body.innerHTML = '<pre style="padding:1rem;color:red">Unhandled Promise rejection: ' + event.reason + '</pre>';
    });

    /**
     * Prompt the user to select a directory using the File System Access API. When a
     * directory is chosen, it is stored on the global `window.selectedDirectoryHandle`.
     * A log entry can be recorded via the provided addLog callback. Selecting
     * directories fails silently if the user cancels the picker.
     *
     * @param {function} addLog optional callback to record log entries
     */
    async function chooseDirectory(addLog) {
      if (!window.showDirectoryPicker) {
        if (addLog) addLog('error', 'File System Access API is not supported in this browser');
        return;
      }
      try {
        const handle = await window.showDirectoryPicker();
        window.selectedDirectoryHandle = handle;
        if (addLog) addLog('info', `Selected data folder: ${handle.name}`);
        // Reload all data from newly selected folder if a handler has been registered
        if (window.onDataFolderChosen) {
          try {
            await window.onDataFolderChosen();
          } catch (e) {
            if (addLog) addLog('error', `Failed to load data from folder: ${e.message}`);
          }
        }
      } catch (err) {
        if (err && err.name !== 'AbortError' && addLog) {
          addLog('error', `Directory selection failed: ${err.message}`);
        }
      }
    }

    // Load data from an XLSX file in the chosen directory or fall back to HTTP/localStorage.
    // The `transform` function maps raw row objects to the desired shape.
    async function loadData(key, transform) {
      // If a directory has been selected, attempt to read the file from it.
      if (window.selectedDirectoryHandle) {
        try {
          const fileHandle = await window.selectedDirectoryHandle.getFileHandle(key);
          const file = await fileHandle.getFile();
          const buf = await file.arrayBuffer();
          const wb = XLSX.read(new Uint8Array(buf), { type: 'array' });
          const sheet = wb.Sheets[wb.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
          return transform(rows);
        } catch (err) {
          // File not found in directory or read error: return empty list to allow fallbacks
          return [];
        }
      }
      // Otherwise attempt to fetch the file from the relative path (for built-in defaults)
      try {
        const res = await fetch(key);
        if (!res.ok) throw new Error('File not found');
        const buf = await res.arrayBuffer();
        const wb = XLSX.read(new Uint8Array(buf), { type: 'array' });
        const sheet = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
        return transform(rows);
      } catch (err) {
        // As a last resort, use localStorage
        const ls = localStorage.getItem(key);
        if (ls) {
          try {
            return JSON.parse(ls);
          } catch (e) {}
        }
        return [];
      }
    }

    // Save an array of objects to an XLSX file in the chosen directory and also to localStorage.
    async function saveData(key, data) {
      // Always persist JSON into localStorage as a lightweight fallback
      try {
        localStorage.setItem(key, JSON.stringify(data));
      } catch (err) {
        console.warn('localStorage setItem failed for', key, err);
      }
      // If a directory has been selected, write the XLSX file into that directory instead of
      // triggering a browser download. Otherwise, fallback to download via writeFile.
      if (window.selectedDirectoryHandle) {
        try {
          const sheet = XLSX.utils.json_to_sheet(data);
          const workbook = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(workbook, sheet, 'Sheet1');
          // Produce an ArrayBuffer for writing
          const arrayBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
          const fileHandle = await window.selectedDirectoryHandle.getFileHandle(key, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(arrayBuffer);
          await writable.close();
          return;
        } catch (err) {
          throw err;
        }
      }
      // Without a directory handle, do not trigger a browser download. Data remains only in localStorage.
      return;
    }

    // Shared persistence helper used by effect watchers.  Will attempt to save using
    // the selected directory and record any errors in the logs via addLog.
    async function callbackPersist(filename, slice, addLog) {
      try {
        await saveData(filename, slice);
      } catch (err) {
        if (addLog) addLog('error', `Failed to save ${filename}: ${err.message}`);
      }
    }

    // Contexts for global store and toasts
    const StoreContext = createContext();
    const ToastContext = createContext();

    // Custom hooks to access contexts
    function useStore() {
      return useContext(StoreContext);
    }
    function useToast() {
      return useContext(ToastContext);
    }

    // Store provider implementing state and actions instead of Zustand
    function StoreProvider({ children }) {
      const [devices, setDevices] = useState([]);
      const [nameRules, setNameRules] = useState([]);
      const [partRules, setPartRules] = useState([]);
      const [logs, setLogs] = useState([]);
      // History of completed devices
      const [history, setHistory] = useState([]);

      // Device actions
      const addDevice = (device) => setDevices((prev) => [...prev, device]);
      const updateDevice = (id, data) => setDevices((prev) => prev.map((d) => d.id === id ? { ...d, ...data } : d));
      const deleteDevice = (id) => setDevices((prev) => prev.filter((d) => d.id !== id));
      const moveDevice = (id, newColumn, newIndex) => setDevices((prev) => {
        const found = prev.find((d) => d.id === id);
        if (!found) return prev;
        const others = prev.filter((d) => d.id !== id);
        found.column = newColumn;
        const left = others.filter((d) => d.column === 'left');
        const right = others.filter((d) => d.column === 'right');
        const list = newColumn === 'left' ? left : right;
        list.splice(newIndex, 0, found);
        return [...left, ...right];
      });

      // History actions
      /**
       * Add a device to the history list. A completedAt timestamp is included by caller.
       * @param {Device} device
       */
      const addHistoryDevice = (device) => setHistory((prev) => [...prev, device]);
      /**
       * Delete a device from history by its id.
       * @param {string} id
       */
      const deleteHistoryDevice = (id) => setHistory((prev) => prev.filter((d) => d.id !== id));

      // Name rule actions
      const addNameRule = (rule) => setNameRules((prev) => [...prev, rule]);
      const updateNameRule = (id, data) => setNameRules((prev) => prev.map((r) => r.id === id ? { ...r, ...data } : r));
      const deleteNameRule = (id) => setNameRules((prev) => prev.filter((r) => r.id !== id));
      const moveNameRule = (id, newIndex) => setNameRules((prev) => {
        const index = prev.findIndex((r) => r.id === id);
        if (index === -1) return prev;
        const arr = prev.slice();
        const [item] = arr.splice(index, 1);
        arr.splice(newIndex, 0, item);
        return arr;
      });

      // Part notification rule actions
      const addPartRule = (rule) => setPartRules((prev) => [...prev, rule]);
      const updatePartRule = (id, data) => setPartRules((prev) => prev.map((r) => r.id === id ? { ...r, ...data } : r));
      const deletePartRule = (id) => setPartRules((prev) => prev.filter((r) => r.id !== id));
      const movePartRule = (id, newIndex) => setPartRules((prev) => {
        const index = prev.findIndex((r) => r.id === id);
        if (index === -1) return prev;
        const arr = prev.slice();
        const [item] = arr.splice(index, 1);
        arr.splice(newIndex, 0, item);
        return arr;
      });

      // Log actions
      const addLog = (level, text) => setLogs((prev) => [
        { id: uuidv4(), ts: dayjs().format('YYYY-MM-DD HH:mm:ss'), level, text },
        ...prev
      ]);

      // Load persisted state on mount
      useEffect(() => {
        (async () => {
          const devs = await loadData('devices.xlsx', (rows) => rows.map((r) => ({
            id: r.id || uuidv4(),
            notification: r.notification || '',
            workOrder: r.workOrder || '',
            partNumber: r.partNumber || '',
            serial: r.serial || '',
            notes: r.notes || '',
            column: r.column === 'right' ? 'right' : 'left'
          })));
          if (devs.length) setDevices(devs);
          const names = await loadData('names.xlsx', (rows) => rows.map((r) => ({ id: r.id || uuidv4(), prefix: r.prefix || '', displayName: r.displayName || '' })));
          if (names.length) setNameRules(names);
          const parts = await loadData('part_notifications.xlsx', (rows) => rows.map((r) => ({ id: r.id || uuidv4(), prefix: r.prefix || '', message: r.message || '' })));
          if (parts.length) setPartRules(parts);
          const ls = await loadData('logs.xlsx', (rows) => rows.map((r) => ({ id: r.id || uuidv4(), ts: r.ts || '', level: r.level || 'info', text: r.text || '' })));
          if (ls.length) setLogs(ls);

          // Load history of completed devices
          const hist = await loadData('history.xlsx', (rows) => rows.map((r) => ({
            id: r.id || uuidv4(),
            notification: r.notification || '',
            workOrder: r.workOrder || '',
            partNumber: r.partNumber || '',
            serial: r.serial || '',
            notes: r.notes || '',
            column: r.column === 'right' ? 'right' : 'left',
            completedAt: r.completedAt || ''
          })));
          if (hist.length) setHistory(hist);
        })();
      }, []);

      // Persist slices when they change
      useEffect(() => { callbackPersist('devices.xlsx', devices, addLog); }, [devices]);
      useEffect(() => { callbackPersist('names.xlsx', nameRules, addLog); }, [nameRules]);
      useEffect(() => { callbackPersist('part_notifications.xlsx', partRules, addLog); }, [partRules]);
      useEffect(() => { callbackPersist('logs.xlsx', logs, addLog); }, [logs]);

      // Persist history when it changes
      useEffect(() => { callbackPersist('history.xlsx', history, addLog); }, [history]);

      // Expose a handler to reload data when the user selects a new directory. This function
      // is attached to the global window so chooseDirectory can invoke it. It will load
      // each slice from the selected folder and update the local state.
      window.onDataFolderChosen = async () => {
        // reload devices
        const devs = await loadData('devices.xlsx', (rows) => rows.map((r) => ({
          id: r.id || uuidv4(),
          notification: r.notification || '',
          workOrder: r.workOrder || '',
          partNumber: r.partNumber || '',
          serial: r.serial || '',
          notes: r.notes || '',
          column: r.column === 'right' ? 'right' : 'left'
        })));
        setDevices(devs);
        const names = await loadData('names.xlsx', (rows) => rows.map((r) => ({ id: r.id || uuidv4(), prefix: r.prefix || '', displayName: r.displayName || '' })));
        setNameRules(names);
        const parts = await loadData('part_notifications.xlsx', (rows) => rows.map((r) => ({ id: r.id || uuidv4(), prefix: r.prefix || '', message: r.message || '' })));
        setPartRules(parts);
        const ls = await loadData('logs.xlsx', (rows) => rows.map((r) => ({ id: r.id || uuidv4(), ts: r.ts || '', level: r.level || 'info', text: r.text || '' })));
        // Merge loaded logs with existing logs instead of overwriting. Older logs from the folder are prepended to keep chronological order.
        setLogs((prev) => [...ls, ...prev]);
        const hist = await loadData('history.xlsx', (rows) => rows.map((r) => ({
          id: r.id || uuidv4(),
          notification: r.notification || '',
          workOrder: r.workOrder || '',
          partNumber: r.partNumber || '',
          serial: r.serial || '',
          notes: r.notes || '',
          column: r.column === 'right' ? 'right' : 'left',
          completedAt: r.completedAt || ''
        })));
        setHistory(hist);
        addLog('info', 'Data loaded from selected folder');
      };

      const storeValue = {
        devices,
        nameRules,
        partRules,
        logs,
        history,
        addDevice,
        updateDevice,
        deleteDevice,
        moveDevice,
        addHistoryDevice,
        deleteHistoryDevice,
        addNameRule,
        updateNameRule,
        deleteNameRule,
        moveNameRule,
        addPartRule,
        updatePartRule,
        deletePartRule,
        movePartRule,
        addLog
      };
      return h(StoreContext.Provider, { value: storeValue }, children);
    }

    // Toast provider implementing simple toast queue
    function ToastProvider({ children }) {
      const [toasts, setToasts] = useState([]);
      const [modalNotif, setModalNotif] = useState(null);

      const showToast = (message, level = 'info') => {
        const id = uuidv4();
        setToasts((prev) => [...prev, { id, message, level }]);
        setTimeout(() => {
          setToasts((prev) => prev.filter((t) => t.id !== id));
        }, 4000);
      };
      const showModal = (message) => setModalNotif(message);
      const hideModal = () => setModalNotif(null);

      return h(ToastContext.Provider, { value: { toasts, showToast, modalNotif, showModal, hideModal } }, [
        // Render modal notification if one is active
        modalNotif ? h('div', { className: 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-40 z-50' },
          h('div', { className: 'bg-white p-4 rounded-lg shadow-lg max-w-sm' }, [
            h('div', { className: 'mb-3 text-gray-800' }, modalNotif),
            h('div', { className: 'flex justify-end' },
              h('button', { className: 'bg-blue-600 text-white px-3 py-1 rounded', onClick: hideModal }, 'OK')
            )
          ])
        ) : null,
        children
      ]);
    }

    // Helper: resolve display name from name rules
    function useDisplayName(partNumber) {
      const { nameRules } = useStore();
      return React.useMemo(() => {
        let match = '';
        let name = 'Unbenanntes Teil';
        for (const r of nameRules) {
          if (partNumber && partNumber.startsWith(r.prefix) && r.prefix.length > match.length) {
            match = r.prefix;
            name = r.displayName;
          }
        }
        return name;
      }, [nameRules, partNumber]);
    }

    // Helper: check part notifications and show toast/log
    function usePartNotificationChecker() {
      const { partRules, addLog } = useStore();
      const { showModal } = useToast();
      return (partNumber) => {
        for (const rule of partRules) {
          if (partNumber && partNumber.startsWith(rule.prefix)) {
            // Show a modal popup for this part notification
            showModal(rule.message);
            addLog('warn', rule.message);
            return;
          }
        }
      };
    }

    // Toast container component
    function ToastContainer() {
      const { toasts } = useToast();
      return h('div', { className: 'fixed top-4 right-4 space-y-2 z-50' },
        toasts.map((t) => h('div', {
          key: t.id,
          className: 'px-4 py-2 rounded shadow-md text-sm text-white ' +
            (t.level === 'warn' ? 'bg-yellow-500' : t.level === 'error' ? 'bg-red-500' : 'bg-gray-700')
        }, t.message))
      );
    }

    // NavBar component
    function NavBar() {
      const location = useLocation();
      const { addLog } = useStore();
      const linkClass = (path) => 'px-3 py-2 rounded-md text-sm font-medium ' +
        (location.pathname === path ? 'bg-blue-100 text-blue-700' : 'text-gray-600 hover:text-blue-700');
      // Determine label for the folder button based on whether a directory is selected
      const folderLabel = window.selectedDirectoryHandle ? window.selectedDirectoryHandle.name : 'Ordner wählen';
      return h('nav', { className: 'bg-white shadow sticky top-0 z-40 flex gap-2 px-4 py-2 items-center' }, [
        h(Link, { to: '/', className: linkClass('/') }, 'Übersicht'),
        h(Link, { to: '/history', className: linkClass('/history') }, 'Historie'),
        h(Link, { to: '/names', className: linkClass('/names') }, 'Namensregeln'),
        h(Link, { to: '/part-notifications', className: linkClass('/part-notifications') }, 'Teile-Benachrichtigungen'),
        h(Link, { to: '/logs', className: linkClass('/logs') }, 'Protokoll'),
        // Spacer to push folder button to the right on larger screens
        h('div', { className: 'flex-grow' }),
        h('button', {
          className: 'bg-blue-50 text-blue-700 px-3 py-1 rounded-md text-sm hover:bg-blue-100',
          onClick: () => chooseDirectory(addLog)
        }, folderLabel)
      ]);
    }

    // Device card component
    function DeviceCard({ device, index, openEdit, confirmDelete, completeDevice, expandedId, setExpandedId }) {
      const { updateDevice } = useStore();
      const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({ id: device.id });
      // Determine whether this card is currently expanded by comparing with the board's expandedId
      const expanded = device.id === expandedId;
      const [notes, setNotes] = useState(device.notes);
      const displayName = useDisplayName(device.partNumber);
      const style = {};
      if (transform) {
        // Allow both horizontal and vertical translations to enable cross-column moves
        style.transform = `translate3d(${transform.x}px, ${transform.y}px, 0)`;
      }
      if (transition) {
        style.transition = transition;
      }
      if (isDragging) {
        style.zIndex = 50;
        style.opacity = 0.7;
      }
      const handleNotesBlur = () => {
        if (notes !== device.notes) {
          updateDevice(device.id, { notes });
        }
      };
      // Collapsed header content with separate drag handle to avoid intercepting click
      // Header shows display name and notification number. Clicking toggles expansion except during dragging.
      const header = h('div', {
        className: 'flex items-center',
        // Toggle expanded state via the parent-managed expandedId. Only toggle when not dragging.
        onClick: () => {
          if (isDragging) return;
          // If this card is already expanded, collapse it; otherwise open it.
          if (expanded) setExpandedId(null); else setExpandedId(device.id);
        }
      }, [
        // Left side: display name and notification
        h('div', { className: 'flex-1' }, [
          h('div', { className: 'font-semibold text-blue-600 truncate' }, displayName),
          // Show notification number with slightly larger font to match the display name
          h('div', { className: 'text-base font-semibold text-gray-500 truncate' }, device.notification)
        ]),
        // Drag handle on the right side: attach sortable listeners and attributes to only this element
        h('div', {
          className: 'pl-2 ml-2 text-gray-400 cursor-move select-none',
          onClick: (e) => e.stopPropagation(),
          ...attributes,
          ...listeners
        }, '⋮')
      ]);
      // Expanded details content
      const expandedContent = expanded ? h('div', {
        className: 'mt-2 text-sm text-gray-700 space-y-1'
      }, [
        h('div', null, `AUN: ${device.workOrder}`),
        h('div', null, `P/N: ${device.partNumber}`),
        h('div', null, `S/N: ${device.serial}`),
        h('div', { className: 'flex gap-4 mt-1 text-sm' }, [
          h('button', { type: 'button', onClick: (e) => { e.stopPropagation(); openEdit(device); }, className: 'text-blue-600 font-bold' }, 'Bearbeiten'),
          h('button', { type: 'button', onClick: (e) => { e.stopPropagation(); completeDevice(device); }, className: 'text-green-600 font-bold' }, 'Abschließen'),
          h('button', { type: 'button', onClick: (e) => { e.stopPropagation(); confirmDelete(device); }, className: 'text-red-600 font-bold' }, 'Löschen')
        ]),
        h('div', { className: 'mt-2' }, h('textarea', {
          className: 'w-full border rounded p-1 text-sm',
          rows: 3,
          value: notes,
          onBlur: handleNotesBlur,
          onChange: (e) => setNotes(e.target.value)
        }))
      ]) : null;
      return h('div', {
        ref: setNodeRef,
        style,
        className: 'bg-white rounded-2xl shadow-md p-3 mt-2 cursor-pointer transition ' + (isDragging ? '' : 'hover:shadow-lg')
      }, [header, expandedContent]);
    }

    // Device modal for add/edit
    function DeviceModal({ open, onClose, onSubmit, initial }) {
      const [notification, setNotification] = useState(initial.notification || '');
      const [workOrder, setWorkOrder] = useState(initial.workOrder || '');
      const [partNumber, setPartNumber] = useState(initial.partNumber || '');
      const [serial, setSerial] = useState(initial.serial || '');
      const [aspenStatus, setAspenStatus] = useState('idle'); // idle|found|notfound
      const { addLog } = useStore();
      const { showToast } = useToast();
      const checkPart = usePartNotificationChecker();
      const doAspenLookup = async () => {
        if (!notification.trim()) return;
        const fileName = 'Geräte nach Termin.XLSX';
        try {
          let buf;
          // If a directory is selected, attempt to read the Aspen file from that folder
          if (window.selectedDirectoryHandle) {
            try {
              const fileHandle = await window.selectedDirectoryHandle.getFileHandle(fileName);
              const file = await fileHandle.getFile();
              buf = await file.arrayBuffer();
            } catch (err) {
              // The file is missing in the selected folder
              setAspenStatus('notfound');
              addLog('error', `Aspen file \"${fileName}\" not found in selected folder`);
              return;
            }
          } else {
            // Fallback to fetching from the same origin if no directory chosen
            const res = await fetch(fileName);
            if (!res.ok) {
              setAspenStatus('notfound');
              addLog('error', `Aspen file \"${fileName}\" could not be fetched`);
              return;
            }
            buf = await res.arrayBuffer();
          }
          // Parse workbook
          const wb = XLSX.read(new Uint8Array(buf), { type: 'array' });
          const sheet = wb.Sheets[wb.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
          const match = rows.find((r) => r.MELDUNGS_NO == notification);
          if (match) {
            setWorkOrder(match.AUFTRAGS_NO || '');
            setPartNumber(match.PART_NO || '');
            setSerial(match.SERIAL_NO || '');
            setAspenStatus('found');
            addLog('info', `Aspen lookup succeeded for notification ${notification}`);
          } else {
            setAspenStatus('notfound');
            addLog('warn', `Aspen lookup: notification ${notification} not found in file`);
          }
        } catch (err) {
          setAspenStatus('notfound');
          addLog('error', `Aspen lookup error: ${err.message}`);
        }
      };
      const handleSubmit = () => {
        if (!notification.trim() || !workOrder.trim()) return;
        onSubmit({ notification: notification.trim(), workOrder: workOrder.trim(), partNumber: partNumber.trim(), serial: serial.trim() });
        if (partNumber.trim()) checkPart(partNumber.trim());
      };
      // Reset fields when the modal opens or when editing a different device
      useEffect(() => {
        if (open) {
          setNotification(initial.notification || '');
          setWorkOrder(initial.workOrder || '');
          setPartNumber(initial.partNumber || '');
          setSerial(initial.serial || '');
          setAspenStatus('idle');
        }
      }, [open, initial.id]);
      if (!open) return null;
      return h('div', { className: 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-40 z-50' },
        h('div', { className: 'bg-white rounded-lg shadow-lg p-6 w-96' }, [
          h('h2', { className: 'text-lg font-semibold mb-4' }, initial.id ? 'Gerät bearbeiten' : 'Gerät hinzufügen'),
          h('div', { className: 'space-y-3' }, [
            h('div', null, [
              h('label', { className: 'block text-sm font-medium text-gray-700' }, 'Meldung'),
              h('div', { className: 'flex items-center gap-2 mt-1' }, [
                h('input', {
                  type: 'text',
                  className: 'flex-1 border rounded p-1',
                  value: notification,
                  onChange: (e) => { setNotification(e.target.value); setAspenStatus('idle'); }
                }),
                h('button', {
                  type: 'button',
                  className: 'text-white px-3 py-1 rounded ' + (aspenStatus === 'found' ? 'bg-emerald-500' : aspenStatus === 'notfound' ? 'bg-rose-500' : 'bg-slate-400 hover:bg-slate-500'),
                  onClick: doAspenLookup
                }, 'Aspen')
              ])
            ]),
            h('div', null, [
              h('label', { className: 'block text-sm font-medium text-gray-700' }, 'AUN'),
              h('input', {
                type: 'text', className: 'w-full border rounded p-1 mt-1', value: workOrder,
                onChange: (e) => setWorkOrder(e.target.value)
              })
            ]),
            h('div', null, [
              h('label', { className: 'block text-sm font-medium text-gray-700' }, 'P/N'),
              h('input', {
                type: 'text', className: 'w-full border rounded p-1 mt-1', value: partNumber,
                onChange: (e) => setPartNumber(e.target.value)
              })
            ]),
            h('div', null, [
              h('label', { className: 'block text-sm font-medium text-gray-700' }, 'S/N'),
              h('input', {
                type: 'text', className: 'w-full border rounded p-1 mt-1', value: serial,
                onChange: (e) => setSerial(e.target.value)
              })
            ])
          ]),
          h('div', { className: 'flex justify-end gap-3 mt-5' }, [
            h('button', { type: 'button', className: 'px-3 py-1 bg-gray-200 rounded', onClick: onClose }, 'Abbrechen'),
            h('button', { type: 'button', className: 'px-3 py-1 bg-blue-600 text-white rounded', onClick: () => { handleSubmit(); onClose(); } }, 'Speichern')
          ])
        ])
      );
    }

    // Generic modal for adding/editing a rule
    function RuleModal({ open, onClose, onSubmit, initial, labels }) {
      const [prefix, setPrefix] = useState(initial.prefix || '');
      const [second, setSecond] = useState(initial.second || '');
      // Update fields when the modal opens or when a different rule is being edited
      useEffect(() => {
        if (open) {
          setPrefix(initial.prefix || '');
          setSecond(initial.second || '');
        }
      }, [open, initial.id]);
      if (!open) return null;
      return h('div', { className: 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-40 z-50' },
        h('div', { className: 'bg-white rounded-lg shadow-lg p-6 w-96' }, [
          h('h2', { className: 'text-lg font-semibold mb-4' }, initial.id ? 'Regel bearbeiten' : 'Regel hinzufügen'),
          h('div', { className: 'space-y-3' }, [
            h('div', null, [
              h('label', { className: 'block text-sm font-medium text-gray-700' }, 'Präfix'),
              h('input', {
                type: 'text', className: 'w-full border rounded p-1 mt-1', value: prefix,
                onChange: (e) => setPrefix(e.target.value)
              })
            ]),
            h('div', null, [
              h('label', { className: 'block text-sm font-medium text-gray-700' }, labels.second),
              h('input', {
                type: 'text', className: 'w-full border rounded p-1 mt-1', value: second,
                onChange: (e) => setSecond(e.target.value)
              })
            ])
          ]),
          h('div', { className: 'flex justify-end gap-3 mt-5' }, [
            h('button', { type: 'button', className: 'px-3 py-1 bg-gray-200 rounded', onClick: onClose }, 'Abbrechen'),
            h('button', {
              type: 'button', className: 'px-3 py-1 bg-blue-600 text-white rounded',
              onClick: () => {
                if (!prefix.trim() || !second.trim()) return;
                onSubmit(prefix.trim(), second.trim());
                onClose();
              }
            }, 'Speichern')
          ])
        ])
      );
    }

    // Column container with sortable list
    function ColumnContainer({ id, label, items, openEdit, confirmDelete, completeDevice, expandedId, setExpandedId }) {
      const { setNodeRef } = useDroppable({ id });
      // Use a faint red background for the right (UC) column; gray for the left column
      const bgClass = id === 'right' ? 'bg-red-50' : 'bg-gray-100';
      // Use min-height instead of fixed height to allow droppable area to extend and capture drag events across columns
      return h('div', { ref: setNodeRef, className: `${bgClass} rounded-2xl p-2 min-h-[70vh] thin-scrollbar overflow-y-auto overflow-x-hidden` }, [
        label ? h('div', { className: 'text-center font-semibold text-gray-500 mb-2' }, label) : null,
        // Provide an id for SortableContext to help dnd-kit distinguish between lists
        h(SortableContext, { id, items: items.map((d) => d.id), strategy: verticalListSortingStrategy },
          items.map((device, idx) => h(DeviceCard, {
            key: device.id,
            device,
            index: idx,
            openEdit,
            confirmDelete,
            completeDevice,
            expandedId: expandedId,
            setExpandedId: setExpandedId
          }))
        )
      ]);
    }

    // Generic rules page (name or part notifications)
    function RulesPage({ isPart }) {
      const {
        nameRules,
        partRules,
        addNameRule,
        updateNameRule,
        deleteNameRule,
        moveNameRule,
        addPartRule,
        updatePartRule,
        deletePartRule,
        movePartRule,
        addLog
      } = useStore();
      const rules = isPart ? partRules : nameRules;
      const [modalOpen, setModalOpen] = useState(false);
      const [editing, setEditing] = useState(null);
      const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
      );
      const moveRule = (id, newIndex) => {
        if (isPart) movePartRule(id, newIndex); else moveNameRule(id, newIndex);
      };
      const handleDragEnd = (event) => {
        const { active, over } = event;
        if (!over) return;
        const oldIndex = rules.findIndex((r) => r.id === active.id);
        const newIndex = rules.findIndex((r) => r.id === over.id);
        if (oldIndex !== -1 && newIndex !== -1 && oldIndex !== newIndex) {
          moveRule(active.id, newIndex);
        }
      };
      const handleAdd = (prefix, second) => {
        const newRule = { id: uuidv4(), prefix, ...(isPart ? { message: second } : { displayName: second }) };
        if (isPart) addPartRule(newRule); else addNameRule(newRule);
        addLog('info', `${isPart ? 'Teile-Benachrichtigungsregel' : 'Namensregel'} ${prefix} hinzugefügt`);
      };
      const handleEdit = (prefix, second) => {
        if (isPart) updatePartRule(editing.id, { prefix, message: second });
        else updateNameRule(editing.id, { prefix, displayName: second });
        addLog('info', `${isPart ? 'Teile-Benachrichtigungsregel' : 'Namensregel'} ${prefix} aktualisiert`);
      };
      const confirmDeleteRule = (rule) => {
        if (window.confirm('Regel löschen?')) {
          if (isPart) deletePartRule(rule.id); else deleteNameRule(rule.id);
          addLog('info', `${isPart ? 'Teile-Benachrichtigungsregel' : 'Namensregel'} ${rule.prefix} gelöscht`);
        }
      };
      return h('div', { className: 'p-4' }, [
        h('div', { className: 'flex justify-between items-center' }, [
          h('h1', { className: 'text-2xl font-bold text-blue-600' }, isPart ? 'Teile-Benachrichtigungen' : 'Namensregeln'),
          h('button', {
            className: 'bg-blue-600 text-white px-3 py-1 rounded shadow hover:bg-blue-700',
            onClick: () => { setEditing(null); setModalOpen(true); }
          }, '+ Regel hinzufügen')
        ]),
        h(DndContext, { sensors, collisionDetection: closestCenter, onDragEnd: handleDragEnd },
          h(SortableContext, { items: rules.map((r) => r.id), strategy: verticalListSortingStrategy },
            h('div', { className: 'mt-4 space-y-2' },
              rules.map((rule) => h(RuleRow, {
                key: rule.id,
                rule,
                isPart,
                onEdit: () => { setEditing(rule); setModalOpen(true); },
                onDelete: () => confirmDeleteRule(rule)
              }))
            )
          )
        ),
        h(RuleModal, {
          open: modalOpen,
          onClose: () => setModalOpen(false),
          onSubmit: (prefix, second) => {
            if (editing) handleEdit(prefix, second); else handleAdd(prefix, second);
          },
          initial: editing || { prefix: '', second: '' },
          labels: { second: isPart ? 'Nachricht' : 'Anzeigename' }
        })
      ]);
    }

    // Rule row component
    function RuleRow({ rule, isPart, onEdit, onDelete }) {
      const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({ id: rule.id });
      const style = {};
      if (transform) style.transform = `translate3d(${transform.x}px, ${transform.y}px, 0)`;
      if (transition) style.transition = transition;
      if (isDragging) style.zIndex = 50;
      return h('div', {
        ref: setNodeRef,
        style,
        className: 'bg-white p-3 rounded shadow flex justify-between items-center ' + (isDragging ? 'opacity-70' : 'hover:shadow-lg')
      }, [
        h('div', { ...attributes, ...listeners, className: 'flex-1 cursor-move' }, [
          h('span', { className: 'font-semibold text-blue-600 mr-2' }, rule.prefix),
          h('span', { className: 'text-gray-700 text-sm' }, isPart ? rule.message : rule.displayName)
        ]),
        h('div', { className: 'flex gap-3 text-sm' }, [
          h('button', { onClick: onEdit, className: 'text-blue-600 font-bold' }, 'Bearbeiten'),
          h('button', { onClick: onDelete, className: 'text-red-600 font-bold' }, 'Löschen')
        ])
      ]);
    }

    // Logs page component
    function LogsPage() {
      const { logs } = useStore();
      const containerRef = useRef(null);
      useEffect(() => {
        if (containerRef.current) containerRef.current.scrollTop = 0;
      }, [logs]);
      return h('div', { className: 'p-4' }, [
        h('h1', { className: 'text-2xl font-bold text-blue-600 mb-3' }, 'Protokoll'),
        h('div', {
          ref: containerRef,
          className: 'bg-gray-100 rounded-lg p-3 h-[70vh] overflow-y-auto thin-scrollbar font-mono text-sm'
        }, logs.map((log) => h('div', { key: log.id, className: 'mb-1' }, [
          h('span', { className: 'text-gray-500' }, '[' + log.ts + '] '),
          h('span', { className: log.level === 'warn' ? 'text-yellow-600' : log.level === 'error' ? 'text-red-600' : 'text-gray-700' }, '[' + log.level.toUpperCase() + '] '),
          log.text
        ])))
      ]);
    }

    // Row for history page showing completed device info
    function HistoryRow({ device }) {
      const displayName = useDisplayName(device.partNumber);
      const { deleteHistoryDevice, addLog } = useStore();
      const handleDelete = () => {
        if (window.confirm('Eintrag löschen?')) {
          deleteHistoryDevice(device.id);
          addLog('info', `Historieneintrag ${device.notification} gelöscht`);
        }
      };
      return h('div', { className: 'bg-white p-3 rounded shadow-md group flex flex-col relative' }, [
        // Info column
        h('div', { className: 'flex-1' }, [
          h('div', { className: 'font-semibold text-blue-600' }, displayName),
          h('div', { className: 'text-sm text-gray-700' }, 'Meldung: ' + device.notification),
          h('div', { className: 'text-sm text-gray-700' }, 'AUN: ' + device.workOrder),
          h('div', { className: 'text-sm text-gray-700' }, 'P/N: ' + device.partNumber),
          h('div', { className: 'text-sm text-gray-700' }, 'S/N: ' + device.serial),
          device.completedAt ? h('div', { className: 'text-xs text-gray-500 mt-1' }, 'Abgeschlossen: ' + device.completedAt) : null
        ]),
        // Delete button aligned to the right and hidden until hover
        h('button', {
          className: 'absolute top-2 right-2 text-red-600 font-bold opacity-0 group-hover:opacity-100 transition',
          onClick: handleDelete
        }, 'Löschen')
      ]);
    }

    // History page listing all completed devices
    function HistoryPage() {
      const { history } = useStore();
      return h('div', { className: 'p-4' }, [
        h('h1', { className: 'text-2xl font-bold text-blue-600 mb-3' }, 'Abgeschlossene Geräte'),
        history.length === 0 ? h('div', { className: 'text-gray-600' }, 'Keine abgeschlossenen Geräte') :
        h('div', { className: 'space-y-2' }, history.map((dev) => h(HistoryRow, { key: dev.id, device: dev })))
      ]);
    }

    // Board page with two columns and drag drop
    function BoardPage() {
      const {
        devices,
        addDevice,
        updateDevice,
        deleteDevice,
        moveDevice,
        addHistoryDevice,
        addLog
      } = useStore();
      const leftDevices = devices.filter((d) => d.column === 'left');
      const rightDevices = devices.filter((d) => d.column === 'right');
      const [addOpen, setAddOpen] = useState(false);
      const [editOpen, setEditOpen] = useState(false);
      const [editingDevice, setEditingDevice] = useState(null);
      // Track the currently expanded device ID to ensure only one card is open at a time
      const [expandedId, setExpandedId] = useState(null);
      const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
      );
      const handleDragEnd = (event) => {
        const { active, over } = event;
        if (!over) return;
        const activeId = active.id;
        const overId = over.id;
        const item = devices.find((d) => d.id === activeId);
        if (!item) return;
        let newColumn;
        if (overId === 'left' || overId === 'right') {
          newColumn = overId;
        } else {
          const overItem = devices.find((d) => d.id === overId);
          newColumn = overItem ? overItem.column : item.column;
        }
        const currentColumn = item.column;
        const listInNew = devices.filter((d) => d.column === newColumn);
        let newIndex;
        if (overId === 'left' || overId === 'right') {
          newIndex = listInNew.length;
        } else {
          const overIndex = listInNew.findIndex((d) => d.id === overId);
          const oldIndex = listInNew.findIndex((d) => d.id === activeId);
          newIndex = overIndex;
          if (currentColumn === newColumn && oldIndex < overIndex) newIndex -= 1;
        }
        if (currentColumn === newColumn && newIndex === listInNew.findIndex((d) => d.id === activeId)) return;
        moveDevice(activeId, newColumn, newIndex);
      };
      const handleAdd = (data) => {
        const device = {
          id: uuidv4(),
          notification: data.notification,
          workOrder: data.workOrder,
          partNumber: data.partNumber,
          serial: data.serial,
          notes: '',
          column: 'left'
        };
        addDevice(device);
        addLog('info', `Gerät ${device.notification} hinzugefügt`);
      };
      const handleEdit = (data) => {
        updateDevice(editingDevice.id, data);
        addLog('info', `Gerät ${editingDevice.notification} aktualisiert`);
      };
      const confirmDelete = (device) => {
        if (window.confirm('Gerät löschen?')) {
          deleteDevice(device.id);
          addLog('info', `Gerät ${device.notification} gelöscht`);
        }
      };

      // Mark a device as completed: remove from active devices and move to history
      const handleComplete = (device) => {
        // Confirm completion in German
        if (!window.confirm('Gerät abschließen?')) return;
        // Remove from current devices
        deleteDevice(device.id);
        // Add to history with a completion timestamp
        addHistoryDevice({ ...device, completedAt: dayjs().format('YYYY-MM-DD HH:mm:ss') });
        addLog('info', `Gerät ${device.notification} abgeschlossen`);
      };
      return h('div', { className: 'p-4' }, [
        h('div', { className: 'flex justify-between items-center' }, [
          h('h1', { className: 'text-2xl font-bold text-blue-600' }, 'Geräte'),
          h('button', {
            className: 'bg-blue-600 text-white px-3 py-1 rounded shadow hover:bg-blue-700',
            onClick: () => setAddOpen(true)
          }, '+ Gerät hinzufügen')
        ]),
        // Use rectIntersection for better cross-column collision detection, especially when columns are empty
        // Use rectIntersection for collision detection to improve cross-column drag behaviour on the board
        h(DndContext, { sensors, collisionDetection: rectIntersection, onDragEnd: handleDragEnd },
          h('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4 mt-4' }, [
            h(ColumnContainer, {
              id: 'left', label: '', items: leftDevices,
              openEdit: (device) => { setEditingDevice(device); setEditOpen(true); },
              confirmDelete,
              completeDevice: handleComplete,
              expandedId,
              setExpandedId
            }),
            h(ColumnContainer, {
              id: 'right', label: 'UC', items: rightDevices,
              openEdit: (device) => { setEditingDevice(device); setEditOpen(true); },
              confirmDelete,
              completeDevice: handleComplete,
              expandedId,
              setExpandedId
            })
          ])
        ),
        h(DeviceModal, { open: addOpen, onClose: () => setAddOpen(false), onSubmit: handleAdd, initial: {} }),
        editingDevice ? h(DeviceModal, {
          open: editOpen,
          onClose: () => { setEditOpen(false); setEditingDevice(null); },
          onSubmit: handleEdit,
          initial: editingDevice
        }) : null
      ]);
    }

    // Main application component
    function App() {
      return h(StoreProvider, null,
        h(ToastProvider, null,
          h(HashRouter, null, [
            h(NavBar, null),
            h(ToastContainer, null),
            h(Routes, null, [
              h(Route, { path: '/', element: h(BoardPage, null) }),
              h(Route, { path: '/history', element: h(HistoryPage, null) }),
              h(Route, { path: '/names', element: h(RulesPage, { isPart: false }) }),
              h(Route, { path: '/part-notifications', element: h(RulesPage, { isPart: true }) }),
              h(Route, { path: '/logs', element: h(LogsPage, null) }),
              h(Route, { path: '*', element: h(BoardPage, null) })
            ])
          ])
        )
      );
    }

    // Render the application
    createRoot(document.getElementById('root')).render(h(App, null));
  </script>
</body>
</html>
